<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>高悦凯的博客</title>
 <link href="http://lanyon.getpoole.comhttp://gyk6985432.github.io/myBlog/atom.xml" rel="self"/>
 <link href="http://lanyon.getpoole.comhttp://gyk6985432.github.io/myBlog/"/>
 <updated>2017-02-15T15:06:45+08:00</updated>
 <id>http://lanyon.getpoole.com</id>
 <author>
   <name>高悦凯</name>
   <email>gyk6985432@gmail.com</email>
 </author>

 
 <entry>
   <title>Coredump In Matplotlib</title>
   <link href="http://lanyon.getpoole.com/2017/02/10/coredump-in-matplotlib/"/>
   <updated>2017-02-10T00:00:00+08:00</updated>
   <id>http://lanyon.getpoole.comhttp://gyk6985432.github.io/myBlog/2017/02/10/coredump-in-matplotlib</id>
   <content type="html">&lt;p&gt;﻿—
layout: post
title: bash on window10中core dump解决方案
—&lt;/p&gt;

&lt;p&gt;在bash on windows10使用python的数据处理模块pandas时，无法画图并报错：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
OMP: Error #100: Fatal system error detected.
OMP: System error #22: Invalid argument
Aborted (core dumped)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;解决方案为：
&lt;a href=&quot;https://github.com/Microsoft/BashOnWindows/issues/785&quot;&gt;export KMP_AFFINITY=disabled&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由于bash on windows仅仅是一个bash, 无法运行画图程序。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Windows下指定python所在目录</title>
   <link href="http://lanyon.getpoole.com/2017/01/02/python-bash/"/>
   <updated>2017-01-02T00:00:00+08:00</updated>
   <id>http://lanyon.getpoole.comhttp://gyk6985432.github.io/myBlog/2017/01/02/python-bash</id>
   <content type="html">&lt;p&gt;一般在安装python时要设置python的环境变量，运行.py文件：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
python ***.py
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;另外一种执行python文件的方式是在.py文件中指定python程序所在路径:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
&lt;span class=&quot;c&quot;&gt;#!/usr/bin/python&lt;/span&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;但是在最新的win10的bashonwindows上面要指定python.exe或在其他bash下执行.py文件时，指定方式要改为：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
#!/c/Python27/python.exe
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这样就可以直接执行了。&lt;/p&gt;

&lt;p&gt;一个小坑:)&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Life Plan</title>
   <link href="http://lanyon.getpoole.com/2016/12/28/life-plan/"/>
   <updated>2016-12-28T00:00:00+08:00</updated>
   <id>http://lanyon.getpoole.comhttp://gyk6985432.github.io/myBlog/2016/12/28/life-plan</id>
   <content type="html">﻿&lt;h1 style=&quot;margin: 0 auto;&quot;&gt;人生周计划&lt;/h1&gt;&lt;br&gt;


输入你的生日(xxxx-xx-xx): 
&lt;input type=&quot;text&quot; width=&quot;50px;&quot; id=&quot;birth&quot; onchange=&quot;count()&quot; /&gt;
&lt;input type=&quot;button&quot; onclick=&quot;count()&quot; value=&quot;go&quot;&gt;


&lt;div class=&quot;mymain&quot; id=&quot;mymain&quot;&gt;&lt;/div&gt;
&lt;p style=&quot;clear: both;&quot;&gt;&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    window.onload = display();
    function display() {
        var m = document.getElementById(&#39;mymain&#39;);
        for (var i = 0; i &lt; 80; i++) {
            var col = document.createElement(&#39;div&#39;);
            col.className = &#39;mycol&#39;;
            for (var j = 0; j &lt; 52; j++) {
                var child = document.createElement(&#39;div&#39;);
                child.className = &#39;item&#39;;
                col.appendChild(child);
            }
            m.appendChild(col);
        }
    }

    function clear(){
        var col0 = document.getElementsByClassName(&#39;mycol&#39;)[0];
        for (var i = 0; i &lt; 80; i++) {
            var e = col0.firstChild;
            for (var j = 0; j &lt; 52; j++) {
                e.className = &#39;item&#39;;
                e = e.nextSibling;
            }
            col0 = col0.nextSibling;
        }
    }

    function count(){
        clear();
        var today = new Date();
        var birth = document.getElementById(&#39;birth&#39;).value.split(&#39;-&#39;);
	if (birth[0]&gt;today.getFullYear() || birth[0] &lt; today.getFullYear()-80
                || birth[1] &gt; 12 || birth[1] &lt; 1
                || birth[1] &gt; 31 || birth[2] &lt; 1) {
                alert(&quot;时间不符合要求，重新输入&quot;);
                return;
        }
        var birthdate = new Date(birth[0], birth[1]-1, birth[2]);
        var weeks = Math.floor((today - birthdate)/(1000*60*60*24*7));
        var old = parseInt(weeks/52, 10);
        var c = weeks%52;
        var col0 = document.getElementsByClassName(&#39;mycol&#39;)[0];
        for (var i = 0; i &lt; old; i++) {
            var e = col0.firstChild;
            for (var j = 0; j &lt; 52; j++) {
                e.className = &#39;pass&#39;;
                e = e.nextSibling;
            }
            col0 = col0.nextSibling;
        }
        var e = col0.firstChild;
        for (var i = 0; i &lt; c; i++) {
            e.className = &#39;pass&#39;;
            e = e.nextSibling;
        }
        var p = document.getElementsByTagName(&#39;p&#39;)[0];
        var more = 4160 - weeks;
        p.innerText = &#39;人的一生是短暂的，从出生到少年时期不懂得时间的宝贵，转眼长大成人。学业的重负耗尽了青春的时光，步入中年又因儿女的成长而两鬓斑白，最后步入老年常常疾病缠身。其中有多少时光是有意义的，有多少时光是白白浪费的，有多少是陪伴亲人度过的，又有多少时光是独自漂泊在外的。假如平平安安活到80岁，那么你已经度过了&#39;+ weeks +&#39;个星期，如今&#39; + old + &#39;岁的你在余下的&#39; + more + &#39;个星期还有什么梦想要实现呢，不要再拖延，不要再等了，马上行动才能防止时间在不经意间溜走。&#39;;
    }

&lt;/script&gt;

&lt;style type=&quot;text/css&quot;&gt;
    .mymain {
        /*width: 100%;*/
	width: 1120px;
    }
    .mycol {
        float: left;
    }
    .item {
        margin: 3px;
        width: 8px;
        height: 8px;
        background-color: #cceecc;
    }
    .pass {
        margin: 3px;
        width: 8px;
        height: 8px;
        background-color: #ff0000;
    }
    p {
        margin: 30px auto;
        font-size: 16px;
        font-family: &quot;Microsoft YaHei&quot;;
    }
&lt;/style&gt;
</content>
 </entry>
 
 <entry>
   <title>垃圾收集器及垃圾收集算法</title>
   <link href="http://lanyon.getpoole.com/2016/09/06/algorithm-of-garbage-collection/"/>
   <updated>2016-09-06T00:00:00+08:00</updated>
   <id>http://lanyon.getpoole.comhttp://gyk6985432.github.io/myBlog/2016/09/06/algorithm-of-garbage-collection</id>
   <content type="html">&lt;p&gt;垃圾收集技术经历过很长时间的发展，已经不需要像C++语言里让每个程序员都要分出一部分精力来处理内存的分配和回收这种繁杂的事情了。在我的理解中，程序或计算机的发展趋势就是用机器来代替人做一些重复的劳动，让人从中解放出来，垃圾回收器也正是这样一种机制。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;一 垃圾回收算法&lt;/h1&gt;

&lt;p&gt;垃圾回收算法有：标记-清除算法、复制算法、标记-整理算法和分代收集算法。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;1 标记-清除算法&lt;/h2&gt;
&lt;p&gt;该算法分为两个阶段，首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。
&amp;gt;一个对象在回收前通常要经历两次标记的过程，如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，则它将会被第一次标记并进行第一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有重写finalize()方法或finalize()已经被虚拟机调用过，则判定为“没有必要执行”。finalize()是对象逃脱死亡命运的最后一次机会。&lt;/p&gt;

&lt;p&gt;接着GC会对F-Queue中的对象执行第二次标记，如果对象通过finalize()方法与引用链相连接，则不会被回收，否则对象将被回收。&lt;/p&gt;

&lt;p&gt;标记-清除算法存在两个不足：标记和清除两个过程的效率都不高，而且标记清除后产生大量的内存碎片。&lt;/p&gt;

&lt;p&gt;其他所有算法都是针对这两个问题进行了改进而产生的。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;2 复制算法&lt;/h2&gt;
&lt;p&gt;复制算法是为解决“效率”问题出现的，它将内存分为两块，每次使用其中一块，当使用的一块用完时，将存活的对象复制到另外一块，然后将原来的空间清理掉，同时解决了内存碎片化的问题。
通常商业虚拟机将内存分为一块Eden和两块Survivor，大小比例为8:1:1，每次使用Eden和其中一块Survivor，将存活对象复制到另一块Survivor上面。
这样做避免了内存空间的浪费，当存活对象较多时，会依赖老年代来进行分配担保。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;3 标记-整理算法&lt;/h2&gt;
&lt;p&gt;复制算法要进行多次复制操作，效率可能会变低，另外分配担保也存在风险，老年代不适合采用这种方法。
标记-整理算法的标记过程与上述过程一样，但并不是直接清理对象，而是让存活的对象向一端移动，清理掉边界以外的内存。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;4 分代收集算法&lt;/h2&gt;
&lt;p&gt;分代收集就是根据对象存活的时间不同，将Java堆分为新生代和老年代，针对不同的对象采用不同的回收算法。&lt;/p&gt;

&lt;h1 id=&quot;section-5&quot;&gt;二 垃圾回收器&lt;/h1&gt;

&lt;p&gt;新生代收集器有：Serial、ParNew、ParallelScavenge。
老年代收集器有：CMS、SerialOld、ParallelOld。
最新收集器：G1。&lt;/p&gt;

&lt;h2 id=&quot;serial&quot;&gt;1 Serial收集器&lt;/h2&gt;
&lt;p&gt;Serial是单线程收集器，采用复制算法，在进行垃圾收集时，必须停止其他工作线程，即Stop The World(STW)。它是虚拟机在Client模式下的默认新生代收集器。
在桌面应用程序中，虚拟机内存一般为几十兆到几百兆，停顿时间大概为几十毫秒到一百多毫秒的范围内，对一般应用程序来说是可以接受的。&lt;/p&gt;

&lt;h2 id=&quot;parnew&quot;&gt;2 ParNew收集器&lt;/h2&gt;
&lt;p&gt;ParNew是Serial收集器的多线程版，也存在Stop The World的问题，除了是多线程的实现外，并没有很多的创新之处。因此ParNew通常运行在Server模式下的新生代收集器。
另外它只能与CMS收集器配合使用。&lt;/p&gt;

&lt;h2 id=&quot;parallel-scavenge&quot;&gt;3 Parallel Scavenge收集器&lt;/h2&gt;
&lt;p&gt;Parallel Scavenge收集器是新生代收集器，采用的是复制算法，其目标是达到一个可控制的吞吐量(Throughput)，即运行用户代码时间/(运行用户代码时间+垃圾收集时间)，因此也被称为“吞吐量优先收集器”。&lt;/p&gt;

&lt;h2 id=&quot;serial-old&quot;&gt;4 Serial Old收集器&lt;/h2&gt;
&lt;p&gt;Serial Old收集器是Serial收集器的老年代版本，也是单线程运行的使用了“标记-整理算法”，以供在Client模式下运行，但在Server模式下可以与Parallel Scavenge收集器配合使用，也可以作为CMS的备选方案。&lt;/p&gt;

&lt;h2 id=&quot;parallel-old&quot;&gt;5 Parallel Old收集器&lt;/h2&gt;
&lt;p&gt;Parallel Old是Parallel Scavenge收集器的老年代版本，使用“标记-整理算法”，在注重吞吐量的场合可以使用Parallel Old和Parallel Scavenge的组合。&lt;/p&gt;

&lt;h2 id=&quot;cms&quot;&gt;6 CMS收集器&lt;/h2&gt;
&lt;p&gt;CMS全称为Concurrent Mark Sweep收集器，可以看出采用的是“标记-清除算法”，其目标是获得最短停顿时间，通常应用在网站或B/S服务器上，以期获得最短停顿时间和最快的响应速度。从总体上说，CMS收集器是与用户线程一起并发执行的，虽然其中也有Stop The World，但相对时间很短。因此也称为“并发低停顿收集器”。
CMS不足之处在于在服务器上工作时会占用一部分线程，使吞吐量降低。另外CMS无法处理浮动垃圾(同时运行的用户线程时产生的新垃圾)。最后使用标记清除算法会产生大量的空间碎片，出现虽然还有内存但无法分配大对象的情况。&lt;/p&gt;

&lt;h2 id=&quot;g1&quot;&gt;7 G1收集器&lt;/h2&gt;
&lt;p&gt;有关G1收集器的原理可参照文章http://www.importnew.com/15311.html&lt;/p&gt;

&lt;p&gt;reference：
1. 深入理解Java虚拟机
2. &lt;a href=&quot;http://jbutton.iteye.com/blog/1569746&quot;&gt;JVM垃圾回收机制&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>在Kali Linux上编译OsmocomBB</title>
   <link href="http://lanyon.getpoole.com/2016/08/08/make-OsmocomBB-on-KaliLinux/"/>
   <updated>2016-08-08T00:00:00+08:00</updated>
   <id>http://lanyon.getpoole.comhttp://gyk6985432.github.io/myBlog/2016/08/08/make-OsmocomBB-on-KaliLinux</id>
   <content type="html">&lt;p&gt;在虚拟机上装了kali Linux很久了，一直没整点成果出来，突发奇想看看试试看手机能不能被窃听。于是上网搜GSM Sniffing，折腾了一天，终于可以了。参考的文章如下（有需要的童鞋请参考大神们的成果）：&lt;/p&gt;

&lt;p&gt;http://www.blogjava.net/baicker/archive/2013/11/13/406293.html
http://holmesian.org/GSM-SMS-Sniffing
http://bbs.acehat.com/forum.php?mod=viewthread&amp;amp;tid=6877&amp;amp;page=1
http://www.evil0x.com/posts/492.html
http://iluck.org/212.html
http://bbs.pediy.com/showthread.php?p=1319244
https://bb.osmocom.org/trac/wiki/Software/GettingStarted?redirectedfrom=GettingStarted
http://bb.osmocom.org/trac/wiki/GnuArmToolchain&lt;/p&gt;

&lt;p&gt;（后面两篇是官方的，参考一下还可以）&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;软件环境搭建&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Linux版本：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Linux kali 3.18.0-kali1-586 #1 Debian 3.18.3-1~kali4 (2015-01-22) i686 GNU/Linux&lt;/p&gt;

&lt;p&gt;开始&lt;/p&gt;

&lt;p&gt;打开一个终端，获得root权限，如果不想获得，后面某些语句加 sudo也可以。&lt;/p&gt;

&lt;p&gt;用vm编辑器或leafpad打开/etc/apt/sources.list文件，把下面三行加在后面&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
deb http://mirrors.ustc.edu.cn/kali kali main non-free contrib
deb-src http://mirrors.ustc.edu.cn/kali kali main non-free contrib
deb http://mirrors.ustc.edu.cn/kali-security kali/updates main contrib non-free
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;执行这两句&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
apt-get update
aptitude install libtool shtool autoconf git-core pkg-config make gcc
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在根目录下创建一个文件夹&lt;/p&gt;

&lt;p&gt;```
    mkdir osmcombb&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd osmcombb ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装交叉编译环境&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
sudo apt-get install build-essential libgmp3-dev libmpfr-dev libx11-6 libx11-dev texinfo flex bison libncurses5  libncurses5-dbg libncurses5-dev libncursesw5 libncursesw5-dbg libncursesw5-dev libpcsclite-dev zlibc zlib1g-dev libmpfr4 libmpc-dev
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
aptitude install libtool shtool automake autoconf git-core pkg-config make gcc
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;```
wget http://bb.osmocom.org/trac/raw-attachment/wiki/GnuArmToolchain/gnu-arm-build.2.sh&lt;/p&gt;

&lt;p&gt;chmod +x gnu-arm-build.2.sh
```&lt;/p&gt;

&lt;p&gt;在osmcombb下创建三个文件夹install，build，src。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
mkdir build install src
cd src/
wget http://ftp.gnu.org/gnu/gcc/gcc-4.5.2/gcc-4.5.2.tar.bz2
wget http://ftp.gnu.org/gnu/binutils/binutils-2.21.1a.tar.bz2
wget ftp://sources.redhat.com/pub/newlib/newlib-1.19.0.tar.g
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;（上面三个文件中，有些大神用的那个链接太久远了，文件损坏了，4.5.2是可以用的。）&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
cd ..
./gnu-arm-build.2.sh
export PATH=$PATH:/root/osmcombb/install/bin
(路径最好写成绝对路径。)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;最好检查一下上面PATH语句有没有加到bashrc中。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
vim ~/.bashrc
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在最后一行如果没有export那句话，请手动加上。经过这么长时间的折腾，终于可以进入下一阶段了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;先来获取libosmocore：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
git clone git://git.osmocom.org/libosmocore.git
cd libosmocore/
autoreconf -i
./configure
make
sudo make install
cd ..
sudo ldconfig
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;最后一句千万不能少，否则后面会发生错误。
&lt;img src=&quot;/images/kali1.jpg&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;获取osmocom-bb：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
git clone git://git.osmocom.org/osmocom-bb.git
cd osmocom-bb
git pull --rebase
git checkout --track origin/luca/gsmmap
cd src
make
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;硬件设备搭建&lt;/h2&gt;

&lt;p&gt;经过多天的等待，硬件终于配齐了。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;C118手机一部&lt;/li&gt;
  &lt;li&gt;USB TO TTL接口一个&lt;/li&gt;
  &lt;li&gt;C118数据线一根。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注：某宝卖的USBTOTTL接口并不太稳定，建议多买一个做备份。上面帖子中有些自己DIY数据线，这个2.5mm的耳机线不太好找，还是直接买一根比较方便。本文只能接收到下行短信，如果某些童鞋要接收上行短信，建议买两个C118手机，防止改装的时候弄坏模块接口。&lt;/p&gt;

&lt;p&gt;设备都有了，剩下就很快啦。&lt;/p&gt;

&lt;p&gt;首先肯定是把设备都查上啦，不过在查上之前，得确保接线正确。数据线三根线分别是红、白、黑。&lt;/p&gt;

&lt;p&gt;红-&amp;gt;TXD
白-&amp;gt;RXD
黑-&amp;gt;GND&lt;/p&gt;

&lt;p&gt;插上后，USBTOTTL应该是亮的，我这个只买了一个，有时候亮有时候不亮，很郁闷。打开一个终端，输入：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
lsusb
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果显示有CP210x，那说明是没问题了。
&lt;img src=&quot;/images/kali2.jpg&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来打开四个终端A、B、C、D。
A中输入：&lt;/p&gt;

&lt;p&gt;```
cd osmocombb/osmocom-bb/src/host/osmocon/&lt;/p&gt;

&lt;p&gt;./osmocon -m c123xor -p /dev/ttyUSB0../../target/firmware/board/compal_e88/layer1.compalram.bin
```&lt;/p&gt;

&lt;p&gt;按一下手机上的红色按键，可能会出现异常：
&lt;em&gt;Received FTMTOOL from phone ,ramloder has aborted。&lt;/em&gt;
这种情况很可能是USBTOTTL有问题，也可能是没插好，如果有备件的话就换一个试试，我这里没有，只能各种xxx了。。。&lt;/p&gt;

&lt;p&gt;如果正常的话，在A中如图：
&lt;img src=&quot;/images/kali3.jpg&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;去B中输入：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
cd osmcombb/osmocom-bb/src/host/layer23/src/misc/
./cell_log -O
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;注：大欧，O
扫描可用的ARFCN。查阅相关资料，移动占用890～909/935～954MHz，ARFCN：1-95；联通占用909～915/954～960MHz，ARFCN：96-124。测试后发现移动32，34能接受到的比较多一些。联通124接收到的比较多一些。
&lt;img src=&quot;/images/kali4.jpg&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在C中，输入：&lt;/p&gt;

&lt;p&gt;```
cd osmocombb/osmocom-bb/src/host/layer23/src/misc/&lt;/p&gt;

&lt;p&gt;./ccch_scan -i 127.0.0.1 -a ARFCN值
```&lt;/p&gt;

&lt;p&gt;在D中输入：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
wireshark -k -i lo -f &#39;port 4729&#39;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;打开wireshark，修改过滤器为gsm_sms。点击apply就可以接受到gsm_sms协议的短信了。在最后一行的TP-USER-DATA中，可以看到短信内容，发送者的还有电话号码。
&lt;img src=&quot;/images/kali5.jpg&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;就到这里罢。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>8种排序法（Java实现）</title>
   <link href="http://lanyon.getpoole.com/2016/07/22/sortings/"/>
   <updated>2016-07-22T00:00:00+08:00</updated>
   <id>http://lanyon.getpoole.comhttp://gyk6985432.github.io/myBlog/2016/07/22/sortings</id>
   <content type="html">&lt;p&gt;内部排序法有8种：冒泡排序法、选择排序法、插入排序法、合并排序法、快速排序法、堆排序法、希尔排序法和基数排序法。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;排序的稳定性：数据经过排序后，两个相同键值的记录仍然保持原来的次序。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;排序方法&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;稳定性&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;冒泡排序法&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;稳定&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;选择排序法&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;不稳定&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;插入排序法&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;稳定&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;希尔排序法&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;不稳定&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;归并排序法&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;稳定&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;快速排序法&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;不稳定&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;堆积排序法&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;不稳定&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;基数排序法&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;稳定&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;前四种都是简单的排序，后三种较为复杂。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;冒泡排序法&lt;/h2&gt;
&lt;p&gt;冒泡排序法为交换排序法的一种，基本思想是从第一个元素开始，与后面一个的元素比较，若顺序有误则二者交换。然后对下一个位置的元素重复上述过程。这样完成一次扫描后，最后一个元素位置是正确的。继续第二次扫描，确定倒数第二个元素，以此类推。
由于只是对相邻元素进行交换，所以是稳定排序。&lt;/p&gt;

&lt;p&gt;复杂度分析：最坏情况需要比较的次数为(n-1)+(n-2)+(n-3)+…+3+2+1=n(n-1)/2，时间复杂度为O(n^2)。最好情况为n-1次比较，时间复杂度为O(n)。只需要一个额外空间，空间复杂度为O(1)。
适用于数据量小或部分数据已经排过序的情况。&lt;/p&gt;

&lt;p&gt;```
//冒泡排序法(Bubble Sort)&lt;/p&gt;

&lt;p&gt;public class BubbleSorting {
    public static void main(String[] args){
        int i,j,tmp;
        int data[] = {6,5,9,7,2,8};  //原始数据&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    System.out.println(&quot;冒泡排序法：&quot;);
    System.out.print(&quot;原始数据为：&quot;);
    for(i=0;i&amp;lt;6;i++){
        System.out.print(data[i]+&quot; &quot;);
    }
    System.out.println();

    for(i=5;i&amp;gt;0;i--){   //扫描次数
        for(j=0;j&amp;lt;i;j++){   //比较、交换次数
            if(data[j]&amp;gt;data[j+1]){
                tmp = data[j];
                data[j] = data[j+1];
                data[j+1] = tmp;
            }
        }

        //打印各次扫描结果
        for(j=0;j&amp;lt;6;j++){
            System.out.print(data[j]+&quot; &quot;);
        }
        System.out.println();
    }

    System.out.println(&quot;排序结果为：&quot;);
    for(i=0;i&amp;lt;6;i++){
            System.out.print(data[i]+&quot; &quot;);
    }
System.out.println();
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-1&quot;&gt;选择排序法&lt;/h2&gt;
&lt;p&gt;对于由小到大排序的情况，进行第一次扫描，从第一个位置开始，在其后依次寻找比它小的元素，从而将最小的元素放在第一个位置。第二次扫描，从第二个位置开始，重复上面的过程。
由于排序时要直接和最前面的元素交换，因此有可能会使原来的次序改变，所以它是不稳定的排序法。&lt;/p&gt;

&lt;p&gt;复杂度分析：每一次扫描过程中都要找到最小元素，然后进行交换，因此比较的次数总是(n-1)+(n-2)+(n-3)+…+3+2+1=n(n-1)/2，时间复杂度为O(n^2)。
此方法适用于数据量小或部分数据已经排过序的情况。&lt;/p&gt;

&lt;p&gt;```
//选择排序法
public class SelectionSorting{&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int data[] = new int[]{9,7,5,3,4,6};
public static void main(String[] args){
    System.out.print(&quot;原始数据为：&quot;);
    SelectionSorting test = new SelectionSorting();
    test.showData();
    test.select();
}

public void showData(){
    int i;
    for (i=0;i&amp;lt;6;i++) {
        System.out.print(data[i]+&quot; &quot;);
    }
    System.out.println();
}

public void select(){
    int i,j,temp;
    for (i=0;i&amp;lt;5;i++) {
        for (j=i+1;j&amp;lt;6;j++) {
            if (data[i]&amp;gt;data[j]) {
                temp=data[i];
                data[i]=data[j];
                data[j]=temp;
            }
        }
        System.out.print(&quot;第&quot;+(i+1)+&quot;次排序：&quot;);
        for (j=0;j&amp;lt;6;j++) {
            System.out.print(data[j]+&quot; &quot;);
        }
        System.out.println();
    }
    System.out.println();
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;插入排序法&lt;/h2&gt;
&lt;p&gt;第一次扫描时，从第二个元素开始，与已经排好序的每个元素比较，将其插入到合适的位置。第二次扫描从第三个元素开始，重复上述过程。
由于将某一个元素插入到合适位置的过程中，元素是逐个依次往后移动，所以是稳定排序。&lt;/p&gt;

&lt;p&gt;复杂性分析：最坏情况需要比较的次数为(n-1)+(n-2)+(n-3)+…+3+2+1=n(n-1)/2，时间复杂度为O(n^2)。最好情况为O(n)。
插入排序法适用于大部分已经排过序，或已排序的数据中新增数据后进行排序的情况。
插入排序中会有大量的数据移动，因此最好在链表上操作。&lt;/p&gt;

&lt;p&gt;```
//插入排序法&lt;/p&gt;

&lt;p&gt;import java.io.*;&lt;/p&gt;

&lt;p&gt;public class InsertSorting{
    int data[] = new int[6];
    int size = 6;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) {
    InsertSorting test = new InsertSorting();
    test.inputarr();
    System.out.print(&quot;您输入的原始数据为： &quot;);
    test.showData();
    test.insert();
}

public void inputarr(){
    int i;
    for (i=0;i&amp;lt;size;i++) {
        System.out.print(&quot;请输入第&quot;+(i+1)+&quot;个元素&quot;);
        try{
            InputStreamReader isr = new InputStreamReader(System.in);
            BufferedReader br = new BufferedReader(isr);
            data[i]=Integer.parseInt(br.readLine());
        }catch(Exception e){
            System.out.println(&quot;输入有误！&quot;);
        }
    }
}

public void showData(){
    int i;
    for (i=0;i&amp;lt;size;i++) {
        System.out.print(data[i]+&quot; &quot;);
    }
    System.out.println();
}

public void insert(){
    int i,j,temp;
    for (i=1;i&amp;lt;size;i++) {
        temp = data[i];
        j=i-1;
        while(j&amp;gt;=0 &amp;amp;&amp;amp; temp&amp;lt;data[j]){
            data[j+1]=data[j];
            j--;
        }
        data[j+1]=temp;
        System.out.print(&quot;第&quot;+i+&quot;次扫描：&quot;);
        showData();
    }
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-3&quot;&gt;希尔排序法&lt;/h2&gt;
&lt;p&gt;希尔排序法是D.L.Shell 于1959年7月发明的一种排序方法。排序的基本思想是将数据分为一定间隔的若干组，采用插入排序法对组内元素排序后，逐渐减小间隔，重复上述过程。
虽然在组内排序采用的是插入排序法，但不同的分组中若含有相同元素，在排列后合并就可能使原来次序改变，因此希尔排序法是不稳定排序。&lt;/p&gt;

&lt;p&gt;复杂度分析：时间复杂度随增量选择不同而不同，希尔增量的时间复杂度为O(n^2)，而Hibbard增量的时间复杂度为O(n^1.5)。空间复杂度为O(1)。有人提倡几乎任何排序工作在开始时都可以用希尔排序，若在实际使用中证明它不够快，再改成快速排序这样更高级的排序算法。希尔排序比直接插入排序快的原因：当n值很大时数据项每一趟排序需要的个数很少，但数据项的距离很长。当n值减小时每一趟需要移动的数据增多，此时已经接近于它们排序后的最终位置。正是这两种情况的结合才使希尔排序效率比插入排序高很多。&lt;/p&gt;

&lt;p&gt;```
//希尔排序法&lt;/p&gt;

&lt;p&gt;import java.io.*;&lt;/p&gt;

&lt;p&gt;public class ShellSorting{
    int data[] = new int[8];
    int size = 8;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) {
    ShellSorting test = new ShellSorting();
    test.inputarr();
    System.out.println(&quot;您输入的原始数据为：&quot;);
    test.showData();
    test.shell();
}

public void inputarr(){
    int i = 0;
    for (i=0;i&amp;lt;size;i++) {
        System.out.print(&quot;请输入第&quot;+(i+1)+&quot;个元素：&quot;);
        try{
            InputStreamReader isr = new InputStreamReader(System.in);
            BufferedReader br = new BufferedReader(isr);
            data[i]=Integer.parseInt(br.readLine());
        }catch(Exception e){
            System.out.println(&quot;输入有误！&quot;);
        }
    }
}

public void showData(){
    for (int i=0;i&amp;lt;size;i++) {
        System.out.print(data[i]+&quot; &quot;);
    }
    System.out.println();
}

public void shell(){
    int i,j,temp,jmp,k;
    k=1;
    jmp = size/2;
    while(jmp&amp;gt;0){
        for (i=jmp;i&amp;lt;size;i++) {
            temp = data[i];
            j=i-jmp;
            while(j&amp;gt;=0 &amp;amp;&amp;amp; data[j]&amp;gt;temp){
                data[j+jmp] = data[j];
                j = j-jmp;
            }
            data[j+jmp] = temp;
        }
        System.out.print(&quot;第&quot;+(k++)+&quot;次排序：&quot;);
        showData();
        jmp = jmp/2;
    }
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-4&quot;&gt;快速排序&lt;/h2&gt;
&lt;p&gt;快速排序是公认的最佳排序法，其基本思想是在数据中找一个中间值，把比它小的放在左边，比它大的放在右边，对相邻的数据重复上述过程。快速排序的步骤为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;取K为第一个键值&lt;/li&gt;
  &lt;li&gt;由左向右找出键值Ki使得Ki&amp;gt;K&lt;/li&gt;
  &lt;li&gt;由右向左找出键值Kj使得Kj&amp;lt;K&lt;/li&gt;
  &lt;li&gt;若i&amp;lt;j，则Ki和Kj交换，并跳到步骤2&lt;/li&gt;
  &lt;li&gt;若i&amp;gt;=j，则将K和Kj交换，以j为基准点将数据分为左右两部分，对左右两部分重复上述过程。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;快速排序是不稳定排序&lt;/p&gt;

&lt;p&gt;复杂度分析：最快情况和平均情况下，时间复杂度为O(nlogn)。最差情况为序列已经排好序，时间复杂度为O(n^2)。最佳情况下空间复杂度为O(logn)，最差情况为O(n)。&lt;/p&gt;

&lt;p&gt;```
//快速排序法&lt;/p&gt;

&lt;p&gt;import java.io.&lt;em&gt;;
import java.util.&lt;/em&gt;;&lt;/p&gt;

&lt;p&gt;public class QuickSorting{
    int size;
    int process=0;
    int[] data = new int[100];&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args){
    QuickSorting test = new QuickSorting();

    System.out.println(&quot;请输入数组大小（100以内）:&quot;);
    try{
        InputStreamReader isr = new InputStreamReader(System.in);
        BufferedReader br = new BufferedReader(isr);
        test.size = Integer.parseInt(br.readLine());
    }catch(Exception e){
        System.out.println(&quot;输入有误&quot;);
    }
    test.inputarr();
    System.out.print(&quot;原始数据为：&quot;);
    test.showData();
    test.quick(test.data,test.size,0,test.size-1);
    System.out.print(&quot;排序结果为：&quot;);
    test.showData();
}

void inputarr(){
    //随机方式输入
    Random rand = new Random();
    for (int i=0;i&amp;lt;size;i++) {
        data[i] = Math.abs(rand.nextInt(99))+1;
    }
}

void showData(){
    for (int i=0;i&amp;lt;size;i++) {
        System.out.print(data[i] + &quot; &quot;);
    }
    System.out.println();
}

void quick(int[] d, int size, int lf, int rg){
    int first,temp;
    int lf_idx;
    int rg_idx;
    int t;


    if (lf&amp;lt;rg) {
        lf_idx = lf+1;
        rg_idx = rg;

        //取出第一个元素K
        first = d[lf];
        while(true){

            System.out.print(&quot;第&quot;+(process++)+&quot;次处理过程：&quot;);
            for (t=0;t&amp;lt;size;t++) {
                System.out.print(d[t]+&quot; &quot;);
            }
            System.out.println();

            //从左向右找出第一个大于K的元素Ki
            for (int i=lf+1;i&amp;lt;rg;i++) {
                if (d[i]&amp;gt;first) {
                    lf_idx=i;
                    break;
                }
                lf_idx++;
            }
            //从右向左找出第一个小于K的元素Kj
            for (int j=rg; j&amp;gt;=lf+1;j--) {
                if (d[j]&amp;lt;=first) {
                    rg_idx=j;
                    break;
                }
                rg_idx--;
            }
            //若i&amp;lt;j，则Ki和Kj交换
            if (lf_idx&amp;lt;rg_idx) {
                temp = d[lf_idx];
                d[lf_idx] = d[rg_idx];
                d[rg_idx] = temp;
            }else{
                break;
            }
        }
        //若i&amp;gt;=j，则K和Kj交换
        if (lf_idx&amp;gt;=rg_idx) {
            temp = d[lf];
            d[lf] = d[rg_idx];
            d[rg_idx] = temp;
            //对分开的两部分各自递归
            quick(d,size,lf,rg_idx-1);
            quick(d,size,rg_idx+1,rg);
        }
    }
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-5&quot;&gt;堆排序&lt;/h2&gt;
&lt;p&gt;堆排序是基于二叉堆原理，二叉堆分为最小二叉堆和最大二叉堆。以最大二叉堆为例，它有三个特点：
1. 它是一个完全二叉树
2. 所有节点的值都大于或等于它左右子节点的值
3. 树根的值是最大的
排序的基本思想是，利用上面第三个特征，将原有数据构建成一个二叉堆，取出其树根元素，将剩下的数据继续构建二叉堆，重复上述过程。&lt;/p&gt;

&lt;p&gt;在算法的实现中，需要一个构建二叉堆的方法，一个把剩余元素调整为二叉堆的方法。&lt;/p&gt;

&lt;p&gt;复杂度分析：任何情况下时间复杂度为O(nlogn)，空间复杂度为O(1)。元素交换时是在父子节点间进行的，相邻节点顺序会被打乱，因此不是稳定排序。&lt;/p&gt;

&lt;p&gt;```
//堆排序法&lt;/p&gt;

&lt;p&gt;public class HeapSorting{
    public static void main(String[] args){
        int size,i;
        size = 9;
        int[] data = {0,5,6,4,8,3,2,7,1};
        System.out.print(“原始数据为：”);
        for (i=1;i&amp;lt;size;i++) {
            System.out.print(data[i]+” “);
        }
        System.out.println();
        HeapSorting.heap(data,size);
        System.out.print(“排序结果：”);
        for (i=1;i&amp;lt;size;i++) {
            System.out.print(data[i]+” “);
        }
        System.out.println();
    }&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void heap(int[] data, int size){
    int i,j,temp;
    for (i=(size/2);i&amp;gt;0;i--) {
        HeapSorting.adjustHeap(data,i,size-1);
    }
    System.out.print(&quot;堆中元素：&quot;);
    for (i=1;i&amp;lt;size;i++) {
        System.out.print(data[i]+&quot; &quot;);
    }
    System.out.println();

    for (i=size-2;i&amp;gt;0;i--) {
        temp = data[i+1];       //将调整过的数据的根元素与最后一个元素交换
        data[i+1] = data[1];
        data[1] = temp;
        HeapSorting.adjustHeap(data,1,i);   //除去最后一个元素，对剩余元素进行调整
        System.out.print(&quot;处理过程：&quot;);
        for (j=1;j&amp;lt;size;j++) {
        System.out.print(data[j]+&quot; &quot;);
        }
        System.out.println();
    }
}

public static void adjustHeap(int[] data, int i, int size){
    int j,temp,post;
    j = 2 * i;
    temp = data[i];     //将根元素暂存
    post = 0;
    while (j&amp;lt;=size &amp;amp;&amp;amp; post==0) {
        if (j&amp;lt;size) {
            if (data[j]&amp;lt;data[j+1]) {   //若左孩子小于右孩子，寻找比当前节点大的孩子节点
                j++;
            }
        }
        if (temp&amp;gt;data[j]) {         //若根元素大于较大的孩子，直接跳出
            post = 1;
        }else{                   //若根元素小于较大的孩子，将该孩子节点向上浮动
            data[j/2] = data[j];
            j = 2*j;
        }
    }
    data[j/2] = temp;       //将原来根元素放到较大的孩子的位置
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;基数排序法&lt;/h2&gt;

&lt;p&gt;基数排序法也叫桶排序法，是分配方式的一种，基本思想是将数据先后按个位、十位、百位…排序，得到最终结果。&lt;/p&gt;

&lt;p&gt;复杂度分析：任何情况下时间复杂度均为O(nlog_p^k)，k是原始数据的最大值。空间复杂度为O(n*p)，n是原始数据的个数，p是最大位数。&lt;/p&gt;

&lt;p&gt;```
//基数排序法&lt;/p&gt;

&lt;p&gt;import java.io.&lt;em&gt;;
import java.util.&lt;/em&gt;;&lt;/p&gt;

&lt;p&gt;public class BucketSorting{&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int size;
int[] data = new int[100];

public static void main(String[] args) {
    BucketSorting test= new BucketSorting();
    System.out.print(&quot;请输入数组大小（&amp;lt;100）：&quot;);
    try{
        InputStreamReader isr = new InputStreamReader(System.in);
        BufferedReader br =  new BufferedReader(isr);
        test.size = Integer.parseInt(br.readLine());
    }catch(Exception e){
        System.out.print(&quot;输入有误&quot;);
    }
    test.inputarr();
    System.out.println(&quot;原始数据为：&quot;);
    test.showData();
    test.bucket();
}

public void showData(){
    for (int i=0;i&amp;lt;size;i++) {
        System.out.print(data[i]+&quot; &quot;);
    }
    System.out.println();
}

public void inputarr(){
    Random r = new Random();
    for (int i=0;i&amp;lt;size;i++) {
        data[i] = Math.abs(r.nextInt(999))+1;;
    }
}

public void bucket(){
    for (int n=1;n&amp;lt;=100;n*=10) {
        int[][] temp = new int[10][100];
        for (int i=0;i&amp;lt;size;i++) {
            int m = (data[i]/n)%10;
            temp[m][i] = data[i];
        }
        int k=0;
        for (int i=0;i&amp;lt;10;i++) {
            for (int j=0;j&amp;lt;size;j++) {
                if (temp[i][j] != 0) {
                    data[k] = temp[i][j];
                    k++;
                }
            }
        }
        System.out.print(n+&quot;位数排序结果：&quot;);
        showData();
    }
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>locate /var/lib/mlocate/mlocate.db</title>
   <link href="http://lanyon.getpoole.com/2016/05/28/locate-linux/"/>
   <updated>2016-05-28T00:00:00+08:00</updated>
   <id>http://lanyon.getpoole.comhttp://gyk6985432.github.io/myBlog/2016/05/28/locate-linux</id>
   <content type="html">&lt;p&gt;今天在CentOS里使用&lt;code class=&quot;highlighter-rouge&quot;&gt;locate&lt;/code&gt;命令时候，报错了：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
locate: can not stat () `/var/lib/mlocate/mlocate.db&#39;: No such file or directory
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/locateError.jpg&quot; alt=&quot;locate&quot; /&gt;&lt;/p&gt;

&lt;p&gt;原因是找不到&lt;code class=&quot;highlighter-rouge&quot;&gt;mlocate.db&lt;/code&gt;数据库文件，因为使用&lt;code class=&quot;highlighter-rouge&quot;&gt;locate&lt;/code&gt;命令时候不是通过遍历文件目录下所有文件来查找的，而是通过数据库进行搜索，这样大大提升了搜索速度。&lt;/p&gt;

&lt;p&gt;解决方法：&lt;/p&gt;

&lt;p&gt;```
sudo yum install mlocate&lt;/p&gt;

&lt;p&gt;sudo updatedb
```&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/updateDB.jpg&quot; alt=&quot;locate&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>在CentOS中编译JDK8</title>
   <link href="http://lanyon.getpoole.com/2016/04/27/build-openjdk8-in-centos/"/>
   <updated>2016-04-27T00:00:00+08:00</updated>
   <id>http://lanyon.getpoole.comhttp://gyk6985432.github.io/myBlog/2016/04/27/build-openjdk8-in-centos</id>
   <content type="html">&lt;p&gt;最近在看《深入理解java虚拟机》，第一章内容就是获取JDK源码，书看了一大半了才决定来亲自试试，毕竟在windows系统上这些东西折腾起来很麻烦。书上编译的是jdk7，因为作者出书的时候还没发布jdk8，既然都2016年了，咱们也得做点新工作，直接编译jdk8，废话不多说了，直接上手吧。&lt;/p&gt;

&lt;p&gt;首先是在VMWare上安装linux，我在这有被坑了，一直比较喜欢ubuntu，所以先在ubuntu上试试，没想到别的都没问题，在make时出现错误，说checked_os_version failed，上网找了半天也没什么结果，所以又装了一个CentOS系统，实践证明，CentOS果然不负众望，怪不得很多书都推荐用这款操作系统，编译过程极其顺利。我的VMWare是32位的，只能编译32的jdk，64位的估计也差不多，下载对了即可。&lt;/p&gt;

&lt;p&gt;安装CentOS就不必多说了，装系统比较简单，无非就是下载，安装，分区。。。&lt;/p&gt;

&lt;p&gt;比较重要的是配置国内的源，默认的CentOS源有点慢，国内还是有很多问题，推荐的是163的源，&lt;a href=&quot;http://jingyan.baidu.com/article/d2b1d1027b76c75c7e37d4d0.html&quot;&gt;百度经验&lt;/a&gt;里有相关的教程，不会的同学可以参考一下。&lt;/p&gt;

&lt;p&gt;接下来下载对应的&lt;a href=&quot;http://download.java.net/openjdk/jdk8/&quot;&gt;jdk8源码包&lt;/a&gt;和bootstrap jdk，这里参考README-builds.html里的教程，应该采用的比较新的jdk7作为bootstrap jdk，直接下载安装jdk7，解压后改名为java，移动到/usr/lib/jvm/下面&lt;/p&gt;

&lt;p&gt;把java环境变量设置一下：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
export JAVA_HOME=/usr/lib/jvm/java
export JRE_HOME=${JAVA_HOME}/jre
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib
export PATH=${JAVA_HOME}/bin:$PATH
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/javaversion.JPG&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;解压jdk8源码包后，进入该文件夹&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
sudo bash ./configure
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;根据提示安装需要的依赖，其中要求安装ccache，在163源里没找到，没有安装也没事，然后直接make即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/finishJDK.JPG&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当然中间省略了很多书中介绍到的命令，本人linux玩的不熟练，那些命令大多都是用来优化编译速度的，也无关紧要。。。&lt;/p&gt;

&lt;p&gt;在openjdk/build下可以看到编译好的jdk源码，大功告成。&lt;/p&gt;

&lt;p&gt;欢迎遇到同样问题的同学前来讨论~~&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>安装jekyll问题解决方案</title>
   <link href="http://lanyon.getpoole.com/2016/03/14/gem-errors/"/>
   <updated>2016-03-14T00:00:00+08:00</updated>
   <id>http://lanyon.getpoole.comhttp://gyk6985432.github.io/myBlog/2016/03/14/gem-errors</id>
   <content type="html">&lt;p&gt;最近忙于论文，更新博客有点少了。前两天写的博客push上来在博客页面也不显示，今天终于有时间弄一下了。
由于这台电脑经常换系统，所以博客出问题也是情理之中，断定是jekyll出问题了。既然如此就充装一下jekyll，但过程却相当曲折，因为要有ruby环境，用gem安装却一直连不上源。&lt;/p&gt;

&lt;p&gt;国内现在比较推荐的是ruby.taobao.org，但我改了之后还是无法连接。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
$ gem sources -r https://rubygems.org/
$ gem sources -a https://ruby.taobao.org/
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/gemError1.PNG&quot; alt=&quot;rubyError1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;官方让加-V，似乎也不管用&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/gemError2.PNG&quot; alt=&quot;rubyError2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;试了半天不管用，有换回原来的了：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
$ gem sources -r https://ruby.taobao.org/
$ gem source -a http://rubygem.org/
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;还是不行，又更新了一下&lt;a href=&quot;http://rubygems.org/&quot;&gt;rubygems&lt;/a&gt;，开了代理后，终于大功告成了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/gemError3.PNG&quot; alt=&quot;rubyError3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/gemError4.PNG&quot; alt=&quot;rubyError4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;真是要折腾死人啊。。。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>atom安装插件的问题</title>
   <link href="http://lanyon.getpoole.com/2016/03/10/atom-install-error/"/>
   <updated>2016-03-10T00:00:00+08:00</updated>
   <id>http://lanyon.getpoole.comhttp://gyk6985432.github.io/myBlog/2016/03/10/atom-install-error</id>
   <content type="html">&lt;p&gt;今天终于准备装最近很火的&lt;a href=&quot;https://atom.io/&quot;&gt;atom&lt;/a&gt;了，据说比SublimeText还牛，这么牛的东西咱肯定得试试啊！下载安装很给力，一键安装，好在软件也不大，只有80+M，听说windows下可以使用apm安装插件，模仿的是大名鼎鼎的npm，那想必非常Diao。&lt;/p&gt;

&lt;p&gt;前段时间看到&lt;开发者头条&gt;上分享的[atom酷炫打字效果](https://atom.io/packages/activate-power-mode/)，着实让人大开眼界。当然，最重要的是markdown支持要好，一边预览一边编辑，那真是飞一样的感觉~&lt;/开发者头条&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/atom1.jpg&quot; alt=&quot;dialog&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看看这界面是不是很帅？&lt;/p&gt;

&lt;p&gt;快捷键一大堆，看的人眼花缭乱，还好有很多是和SublimeText相同的，然并卵。&lt;/p&gt;

&lt;p&gt;插件是个大坑啊，有的人顺利直接就装上了，可惜很多人没那么幸运，安装第一个插件就卡住了。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
Compiler Tool not found!
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;居然说我没有安装python和visual studio！！怎么可能？？&lt;/p&gt;

&lt;p&gt;网上解决方案并不多，终于找到一个解决方案，还在知乎回答了下这个问题：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/38098629/answer/90036256?from=profile_answer_card&quot;&gt;我在知乎回答&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然而这种解决方式对我这样的强迫症并没有什么效果，解决不了？我跟你拼了！&lt;/p&gt;

&lt;p&gt;所以？google啊！&lt;/p&gt;

&lt;p&gt;综合各个论坛什么的，总结如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;apm代理问题&lt;/li&gt;
  &lt;li&gt;node-gyp重定向&lt;/li&gt;
  &lt;li&gt;环境变量设置问题&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;到底怎么解决呢？
当然是开个代理了（自己找梯子），dos下设置代理&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
$ apm config set strict-ssl false
$ apm config set http-proxy http://127.0.0.1:1080
$ apm config set https-proxy http://127.0.0.1:1080
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;（具体可参考https://github.com/atom/apm）&lt;/p&gt;

&lt;p&gt;这样应该解决了吧？什么？还不行？&lt;/p&gt;

&lt;p&gt;参考下这篇文章中&lt;a href=&quot;https://github.com/atom/apm/issues/322&quot;&gt;@TedThiCo&lt;/a&gt;的回答。&lt;/p&gt;

&lt;p&gt;这还差不多。。。&lt;/p&gt;

&lt;p&gt;这个折腾好了，接下来使劲爽吧！！！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>与ubuntu一见钟情的故事</title>
   <link href="http://lanyon.getpoole.com/2016/01/23/story-of-ubuntu-and-me/"/>
   <updated>2016-01-23T00:00:00+08:00</updated>
   <id>http://lanyon.getpoole.comhttp://gyk6985432.github.io/myBlog/2016/01/23/story-of-ubuntu-and-me</id>
   <content type="html">&lt;p&gt;前天重装的centOS系统经过一番折腾，果断还是放弃了，各种软件都装不上，感觉源都不行，加上本人也是linux小白，搞的不欢而散。&lt;/p&gt;

&lt;p&gt;本来呢是想下载个盗版的windows10，在这台电脑上凑合用吧，不知是鬼使神差还是机缘巧合，windows10没下载下来，下了个ubuntu14.0.4……那好吧，先试试ubuntu好不好用吧。&lt;/p&gt;

&lt;p&gt;也许真的是缘分，装系统时候连分区啥的都没找到，直接输了个用户名和密码，系统就装好了。紧接着，自带输入法跟shi一样，也不知道它是什么情况，打字各种出问题，经过一番百度，bing…好不容易装了个搜狗输入法，打字终于舒服了（这不是找虐吗？）。OK，接下来，在CentOS上没完成的，试试在ubuntu上能不能行，先装个为之笔记(wiznote)，事实证明，ubuntu上这些事情还是容易的多。在CentOS上想装个wiz的依赖，一夜没关电脑，第二天还是不行，真是受够了。ubuntu上很容易就成功了，看着我那一堆笔记，心里觉得好满足（咳咳）。&lt;/p&gt;

&lt;p&gt;有了云笔记只够自恋的，怎么也得有个顺手的浏览器吧，linux都自带firefox，说实话firefox界面跟chrome比起来真的太丑了，总是没有chrome那种感觉，装这个chrome在CentOS上也没成功，老是提示Core dumped，各种google都没解决，妈的，我想要的软件一个都装不上，不要它也罢！在ubuntu上三句代码直接搞定。
然而，有了chrome光能上百度也不行啊，sb百度搜啥啥没有，跟bing比起来都差远了，不信你上去搜和shadowsocks试试，连个毛都没有，google大法好啊！一搜一个准，五毛党再猖狂，我还是要抱google的大腿，谷歌身下死，做鬼也风流（别想多啊）～～
要说架梯子，还是shadowsocks好，在windows下跟坐飞机一样爽，在女朋友的mac上也没听到一句抱怨，好了，该证明一下linux上的效果了。
经过一番bing，终于配置好了，看到了GOOGLE的logo真的好满足好满足。
哦对了，最后一个神器，git可不能少，有了这几样，终于可以端端正正地在ubuntu上冲浪编程了，就此开始了新的旅程，bless me……&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>CentOS6.7上安装git</title>
   <link href="http://lanyon.getpoole.com/2016/01/21/install-git-in-CentOS/"/>
   <updated>2016-01-21T00:00:00+08:00</updated>
   <id>http://lanyon.getpoole.comhttp://gyk6985432.github.io/myBlog/2016/01/21/install-git-in-CentOS</id>
   <content type="html">&lt;p&gt;昨天把原先用的电脑翻出来，发现还是WindowsXP，虽然换了新电脑，但也不能让旧的就压箱底吧，所以为了让它继续发挥价值，给它装个linux，也好让我多熟悉熟悉linux，以后说不定要用到呢，废话不多说了，制作启动U盘，装系统什么的直接略过，先给它武装一个神武器git，别的慢慢再说吧。&lt;/p&gt;

&lt;p&gt;由于CentOS的默认源上没有git，改成国内最大的163源也还是没有.&lt;/p&gt;

&lt;p&gt;1.进入目录&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
cd /usr/local/src
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2.安装git需要的依赖：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
yum install curl curl-devel zlib-devel openssl-devel perl cpio expat-devel gettext-devel
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3.下载git包&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
wget http://git-core.googlecode.com/files/git-1.7.7.5.tar.gz
autoconf
./configure
make
make install
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;4.安装完成&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
git --version
&lt;/code&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>JVM中的四种引用</title>
   <link href="http://lanyon.getpoole.com/2016/01/20/References-in-JVM/"/>
   <updated>2016-01-20T00:00:00+08:00</updated>
   <id>http://lanyon.getpoole.comhttp://gyk6985432.github.io/myBlog/2016/01/20/References-in-JVM</id>
   <content type="html">&lt;p&gt;看过某些博客中看到，在面试中有时会问到“弱引用”的问题，很多面试者都答不上来，让我也一直很迷惑。在书中看到才真正理解了不同“引用”的作用，终于知道了finalize()方法的作用。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;可达性分析算法&lt;/h2&gt;
&lt;p&gt;主流语言包括Java、C#等都是通过可达性分析来判定对象是否应该继续存活。其基本思想是设置一系列的起始点（GC Roots）对象，沿着引用链（Reference Chain）向下搜索，当一个对象没有任何路径能够到达GC Roots时，说明对象是不可达的。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;四种引用&lt;/h2&gt;
&lt;p&gt;JDK1.2中对引用的概念进行了扩充，分为：
- 强引用（Strong Reference）
- 软引用（Soft Reference）
- 弱引用（Weak Reference）
- 虚引用（Phantom Reference）&lt;/p&gt;

&lt;p&gt;强引用是指在程序代码中普遍存在的“Object obj = new Object()”一类引用，垃圾回收器永远不会对有强引用的对象进行回收。&lt;/p&gt;

&lt;p&gt;软引用描述的是有用但并非必需的对象，。系统在将要发生内存溢出异常之前，会把软引用的对象进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。&lt;/p&gt;

&lt;p&gt;弱引用也是描述非必需对象的，但它比软引用更弱，被弱引用关联的对象只能生存道下一次垃圾收集发生之前。无论当前内存是否足够，都会回收被弱引用关联的对象。&lt;/p&gt;

&lt;p&gt;虚引用又称为幽灵引用或幻影引用，是最弱的一种引用关系。一个对象是否有虚引用，完全不影响其生存时间，也无法通过虚引用来生成一个对象实例。虚引用唯一的作用是，在对象被回收时会受到一个系统通知。&lt;/p&gt;

&lt;h2 id=&quot;finalize&quot;&gt;finalize()方法&lt;/h2&gt;
&lt;p&gt;当一个对象变得不可达时，系统并不会立即给它判死刑，且马上进行回收。在它死之前还会给它一次机会，也就是第一次给予严重警告，如果它不能自我救赎，第二次就了结它。那如何标记是第一次还是第二次呢？这就要借助finalize()方法了。
如果一个对象没有实现finalize()方法，或者已经调用过finalize()方法，就认定它没有机会了，直接进行回收。如果它有finalize()方法并且没有执行过，就给它一次机会，这时此对象将被放置到一个叫做F-QUEUE的队列中，并在稍后由Finalizer线程去执行。Finalizer线程是由虚拟机自动建立、具有低优先级的一个线程。
此时，虽然该对象的finalize()被执行了，但虚拟机并不会等待它结束，防止它执行缓慢或陷入死循环，让F-QUEUE中其他对象永久处于等待状态，导致整个内存回收系统崩溃。
finalize()方法是对象逃过鬼门关的最后一次机会，稍后GC将对F-QUEUE中的对象进行第二次小规模标记，对象要成功地拯救自己，只有重新与引用链上的任何一个对象建立关联，这时它将不再是“即将”被回收的对象了。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>粒子时钟</title>
   <link href="http://lanyon.getpoole.com/2016/01/17/canvas-clock/"/>
   <updated>2016-01-17T00:00:00+08:00</updated>
   <id>http://lanyon.getpoole.comhttp://gyk6985432.github.io/myBlog/2016/01/17/canvas-clock</id>
   <content type="html">在慕课网上学了个动态时钟，全部用canvas实现的。
自己改成了一个粒子时钟，放上来玩玩。屏幕拉动太快了，容易崩掉，对粒子数目限制了一下，稍稍好一些。也可以设置成彩色的，不过还是黑白的好看～～可以直接另存页面下载下来，改成自己喜欢的样子。



&lt;canvas id=&quot;canvas&quot;&gt;
    您的浏览器不支持canvas，请更换浏览器
&lt;/canvas&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    digit =
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0],
            [0,0,0,0],
            [0,1,1,0],
            [0,1,1,0],
            [0,0,0,0],
            [0,0,0,0],
            [0,1,1,0],
            [0,1,1,0],
            [0,0,0,0],
            [0,0,0,0]
        ]//:
    ];

var WINDOW_WIDTH = 1024;
var WINDOW_HEIGHT = 768;
var RADIUS = 6;
var DOT_RADIUS = Math.round(RADIUS/5);
var MARGIN_TOP = 100;
var MARGIN_LEFT = 200;
var endTime = new Date();
endTime.setTime(endTime.getTime() + 3600*1000);
var currentShowTimeSeconds=0;

var balls = [];
//var colors = [&quot;#008000&quot;,&quot;#00ffff&quot;,&quot;#FF7F50&quot;,&quot;#DC143&quot;,&quot;#00008B&quot;,&quot;#DC143C&quot;,&quot;#FF8C00&quot;,&quot;#E9967A&quot;,&quot;#008000&quot;,&quot;##9ACD32&quot;];
var colors = [&quot;#000000&quot;,&quot;#000000&quot;,&quot;#000000&quot;,&quot;#000000&quot;,&quot;#000000&quot;,&quot;#000000&quot;,&quot;#000000&quot;,&quot;#000000&quot;,&quot;#000000&quot;,&quot;##000000&quot;];

window.onload = function(){

    WINDOW_WIDTH = Math.round(document.body.clientWidth*1.5);
    WINDOW_HEIGHT=Math.round(document.body.clientHeight*1.5);
    //屏幕自适应
    // WINDOW_WIDTH = document.getElementById(&quot;main&quot;).offsetWidth;
    // WINDOW_HEIGHT=document.getElementById(&quot;main&quot;).offsetHeight;
    // MARGIN_LEFT = Math.floor(WINDOW_WIDTH/10);
    MARGIN_LEFT = 0;
    MARGIN_TOP = Math.floor(WINDOW_HEIGHT/5);
    //RADIUS = Math.floor(WINDOW_WIDTH*3/5/108)-1;
    RADIUS=5;
    DOT_RADIUS = Math.floor(RADIUS/5);

    var canvas = document.getElementById(&quot;canvas&quot;);
    var context = canvas.getContext(&quot;2d&quot;);

    canvas.width = WINDOW_WIDTH;
    canvas.height = WINDOW_HEIGHT;

    currentShowTimeSeconds = getCurrentShowTimeSeconds();
    setInterval(function(){
        render(context);
        update();
    },50);
}

function render(cxt){
    cxt.clearRect(0,0,WINDOW_WIDTH,WINDOW_HEIGHT);

    var hour = parseInt(currentShowTimeSeconds/3600);
    var minite = parseInt((currentShowTimeSeconds-hour*3600)/60);
    var second = currentShowTimeSeconds%60;

    renderDigit(MARGIN_LEFT,MARGIN_TOP,parseInt(hour/10),cxt);//位置，数字，cxt  parseInt(minite/10)
    renderDigit(MARGIN_LEFT+15*(RADIUS+1),MARGIN_TOP,parseInt(hour%10),cxt);
    renderDigit(MARGIN_LEFT+30*(RADIUS+1),MARGIN_TOP,10,cxt);
    renderDigit(MARGIN_LEFT+39*(RADIUS+1),MARGIN_TOP,parseInt(minite/10),cxt);
    renderDigit(MARGIN_LEFT+54*(RADIUS+1),MARGIN_TOP,parseInt(minite%10),cxt);
    renderDigit(MARGIN_LEFT+69*(RADIUS+1),MARGIN_TOP,10,cxt);
    renderDigit(MARGIN_LEFT+78*(RADIUS+1),MARGIN_TOP,parseInt(second/10),cxt);
    renderDigit(MARGIN_LEFT+93*(RADIUS+1),MARGIN_TOP,parseInt(second%10),cxt);

    for (var i = 0; i &lt; balls.length; i++) {
        cxt.fillStyle=balls[i].color;
        cxt.beginPath();
        cxt.arc(balls[i].x,balls[i].y,balls[i].r,0,2*Math.PI);
        cxt.closePath;
        cxt.fill();
    };
}

function renderDigit(x, y, num, cxt){       //centerX=x+j*2(R+1)+(R+1)      centerY = y+i*2(R+1)+(R+1)

    cxt.fillStyle = &quot;rgb(0,0,0)&quot;;

    for (var i = 0; i &lt; digit[num].length; i++) {
        for (var j = 0; j &lt; digit[num][i].length; j++) {
            if (digit[num][i][j]==1) {
                for (var k = 0; k &lt; 5; k++) {
                    for (var l = 0; l &lt; 5; l++) {
                        cxt.beginPath();
                        cxt.arc(x+j*2*(RADIUS+1)+(RADIUS+1)+l*2*(DOT_RADIUS+1)+(DOT_RADIUS+1),y+i*2*(RADIUS+1)+(RADIUS+1)+k*2*(DOT_RADIUS+1)+(DOT_RADIUS+1),DOT_RADIUS,0,2*Math.PI);
                        cxt.closePath();
                        cxt.fill();
                    };
                };
                // cxt.beginPath();
                // cxt.arc(x+j*2*(RADIUS+1)+(RADIUS+1),y+i*2*(RADIUS+1)+(RADIUS+1),RADIUS,0,2*Math.PI);
                // cxt.closePath();
                // cxt.fill();
            };
        };
    };

}

function getCurrentShowTimeSeconds(){
    var currTime = new Date();
    //倒计时
    // var ret = endTime.getTime() - currTime.getTime();
    // ret = Math.round(ret/1000);
    // return ret&gt;=0 ? ret : 0;

    //时钟
    var ret = currTime.getHours()*3600+currTime.getMinutes()*60+currTime.getSeconds();
    return ret;
}

function update(){
    var nextShowTimeSeconds = getCurrentShowTimeSeconds();

    var nextHour = parseInt(nextShowTimeSeconds/3600);
    var nextMinite = parseInt((nextShowTimeSeconds-nextHour*3600)/60);
    var nextSecond = nextShowTimeSeconds%60;

    var curHour = parseInt(currentShowTimeSeconds/3600);
    var curMinite = parseInt((currentShowTimeSeconds-curHour*3600)/60);
    var curSecond = currentShowTimeSeconds%60;

    if (nextSecond != curSecond) {

        if (parseInt(curHour/10) != parseInt(nextHour/10)) {
            addBalls(MARGIN_LEFT,MARGIN_TOP,parseInt(curHour/10));
        };
        if (parseInt(curHour%10) != parseInt(nextHour%10)) {
            addBalls(MARGIN_LEFT+15*(RADIUS+1),MARGIN_TOP,parseInt(curHour%10));
        };
        if (parseInt(curMinite/10) != parseInt(nextMinite/10)) {
            addBalls(MARGIN_LEFT+39*(RADIUS+1),MARGIN_TOP,parseInt(curMinite/10));
        };
        if (parseInt(curMinite%10) != parseInt(nextMinite%10)) {
            addBalls(MARGIN_LEFT+54*(RADIUS+1),MARGIN_TOP,parseInt(curMinite%10));
        };
        if (parseInt(curSecond/10) != parseInt(nextSecond/10)) {
            addBalls(MARGIN_LEFT+78*(RADIUS+1),MARGIN_TOP,parseInt(curSecond/10));
        };
        if (parseInt(curSecond%10) != parseInt(nextSecond%10)) {
            addBalls(MARGIN_LEFT+93*(RADIUS+1),MARGIN_TOP,parseInt(curSecond%10));
        };
        currentShowTimeSeconds = nextShowTimeSeconds;
    };
    updateBalls();
}

function addBalls(x,y,num){
    for (var i = 0; i &lt; digit[num].length; i++) {
        for (var j = 0; j &lt; digit[num][i].length; j++) {
            if (digit[num][i][j]==1) {
                for (var k = 0; k &lt; 10; k++) {
                    var aBall={
                    x:x+j*2*(RADIUS+1)+(RADIUS+1),
                    y:y+i*2*(RADIUS+1)+(RADIUS+1),
                    g:1.5+Math.random(),
                    vx:Math.pow(-1,Math.ceil(Math.random()*1000))*Math.floor(Math.random()*30),
                    vy:Math.pow(-1,Math.ceil(Math.random()*1000))*Math.floor(Math.random()*30),
                    r:DOT_RADIUS,
                    color: colors[Math.floor(Math.random()*colors.length)]
                    };
                    balls.push(aBall);
                };
            };
        };
    };
}

function updateBalls(){
    //console.log(balls.length);

    for (var i = 0; i &lt; balls.length; i++) {
        balls[i].x += balls[i].vx;
        balls[i].y += balls[i].vy;
        balls[i].vy += balls[i].g;

        if (balls[i].y &gt;= WINDOW_HEIGHT-RADIUS) {
            //暂时删掉这句
            //balls[i].y=WINDOW_HEIGHT-RADIUS;
            //balls[i].vy = -balls[i].vy*0.75;
        };
        if (balls[i].vx==0) {
            balls[i].vx -= 5;
        };
    };

    //删掉不在画面中的小球，提高性能
    var cnt=0;
    for (var i = 0; i &lt; balls.length; i++) {
        if(balls[i].x+RADIUS &gt; 0 &amp;&amp; balls[i].x-RADIUS&lt;WINDOW_WIDTH ){
            balls[cnt++] = balls[i];
        }
    };

    while(balls.length &gt; cnt || balls.length&gt;900){
        //Math.min(300,cnt)
        balls.pop();
    }
}
&lt;/script&gt;
</content>
 </entry>
 
 <entry>
   <title>JVM内存区域及作用</title>
   <link href="http://lanyon.getpoole.com/2016/01/14/JVM-memory-distr/"/>
   <updated>2016-01-14T00:00:00+08:00</updated>
   <id>http://lanyon.getpoole.comhttp://gyk6985432.github.io/myBlog/2016/01/14/JVM memory distr</id>
   <content type="html">&lt;p&gt;最近在看《深入理解JAVA虚拟机》，刚看到内存区域划分及其所管理的内容。虽然在其他博客上也看过类似的文章，但书里介绍的还是更加详尽透彻。这些区域不太好记，容易遗忘，写篇博客常常回来温习一下也好。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;运行时数据区域&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/Java VM structure.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;program-counter-register&quot;&gt;程序计数器（Program Counter Register）&lt;/h4&gt;
&lt;p&gt;程序计数器是一块较小的内存空间，可看作当前线程执行的字节码的行号指示器。用来给&lt;em&gt;字节码解释器&lt;/em&gt;进行选取字节码指令，以及分支、循环、跳转、异常处理、线程恢复等功能。
为了线程切换后能恢复到正确的执行位置，需要给每条线程都创建一个程序计数器，因而也叫“线程私有”的内存。如果线程执行的java方法，该计数器指向的是正在执行的字节码地址，若是Native方法，则指向空（Undefined）。
此内存区域是java虚拟机唯一一个没有规定任何OutOfMemoryError的区域。&lt;/p&gt;

&lt;h4 id=&quot;javajava-virtual-machine-stacks&quot;&gt;Java虚拟机栈（Java Virtual Machine Stacks）&lt;/h4&gt;
&lt;p&gt;这块区域也是线程私有的，其生命周期与线程相同。
虚拟机栈是给&lt;strong&gt;执行java方法&lt;/strong&gt;服务的。每个java方法执行时都会创建一个&lt;strong&gt;栈帧(Stack Frame)&lt;/strong&gt;，用于存储局部变量表、操作数栈、动态链接、方法出口等。java方法的调用的过程对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；若虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。&lt;/p&gt;

&lt;h4 id=&quot;native-method-stack&quot;&gt;本地方法栈（Native Method Stack）&lt;/h4&gt;
&lt;p&gt;本地方法栈和虚拟机栈的区别在于它是为Native方法服务的。虚拟机规范对本地方法栈中使用的语言、使用方式和数据结构没有强制规定，不同虚拟机可自由实现。而虚拟机栈中用到的boolean、byte、char、int、double、对象引用的内存分配都在编译时候分配完成，进入一个方法时栈帧的局部变量空间是完全确定的，运行期间不会改变。&lt;/p&gt;

&lt;h4 id=&quot;javajava-heap&quot;&gt;Java堆（Java Heap）&lt;/h4&gt;
&lt;p&gt;java堆是内存中最大的部分，所有线程所共享的，虚拟机启动时创建，用来存放对象实例和数组。内存回收也是主要针对这部分，为了便于回收，java堆会被分成Eden、From Survivor、To Survivor等，这部分内容以后进行介绍。
如果堆中没有内存分配给实例，并且堆也无法扩展时将会抛出OutOfMemoryError异常。&lt;/p&gt;

&lt;h4 id=&quot;method-area&quot;&gt;方法区（Method Area）&lt;/h4&gt;
&lt;p&gt;方法区也是所有线程共享的区域，用来存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。方法区也是java堆的逻辑部分，但为了与java堆有所区别，也叫&lt;em&gt;非堆(Non-Heap)&lt;/em&gt;。虽然有些称方法区为“永久代”，但这却不是绝对的，垃圾回收器主要对这部分中的常量池的进行回收和类型的卸载，防止某些时候出现的内存泄漏。。
虚拟机规范规定，方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。&lt;/p&gt;

&lt;h4 id=&quot;runtime-constant-pool&quot;&gt;运行时常量池（Runtime Constant Pool）&lt;/h4&gt;
&lt;p&gt;运行时常量池是方法区的一部分，Class文件中除了类的信息、字段、方法、接口等外，还有一项&lt;em&gt;常量池（Constant Pool Table）&lt;/em&gt;用于存放编译期生成的各种字面量和符号引用，这部分内容要放到运行时常量池中存放。
但是运行时常量池不仅可以存放编译期生成的常量部分，也可在运行时将新的常量放入池中，，具有动态存储的特性。如String的intern()方法。
运行时长两次无法申请到内存时会抛出OutOfMemoryError异常。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;直接内存&lt;/h4&gt;
&lt;p&gt;这部分不是运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但由于会经常使用，也应该予以关注。
JDK1.4中新加入的NIO类，引入了基于通道（channel）与缓冲区（Buffer）的I/O方式，可以使用Native函数库直接分配堆外内存，通过DirectByteBuffer对象作为这块内存的引用进行操作。这种方法能显著提高性能，避免了java堆和Native堆中来回复制数据。
在配置虚拟机参数时，要兼顾这部分直接内存，保证总内存大于各内存区域总和，防止导致出现OutOfMemoryError异常。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>作家的33项写作技巧</title>
   <link href="http://lanyon.getpoole.com/2015/12/22/33TipsToBeGoodWriter/"/>
   <updated>2015-12-22T00:00:00+08:00</updated>
   <id>http://lanyon.getpoole.comhttp://gyk6985432.github.io/myBlog/2015/12/22/33TipsToBeGoodWriter</id>
   <content type="html">&lt;p&gt;在这个互联网时代，&lt;strong&gt;每个人都要懂点写作&lt;/strong&gt;。文科出身的还好，大多理工科出身的完全不懂怎么写才会吸引读者，怎么写才能表达清楚，让读者能看的懂，看的有意思，还能感悟到一些东西。因此跟作家学学写作的一些技巧吧。&lt;/p&gt;

&lt;p&gt;作家&lt;strong&gt;James Altucher&lt;/strong&gt;在部落格上整理了他的33个独门建议，分享他对于写作的技巧与看法！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/33-Unusual-Tips-To-Being-A-Better-Writer.jpg&quot; alt=&quot;33tips of writing&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;写作不需要別人批准。不要说「我的看法是ooxx」。大家都知道是你的看法。文章就你写的呀。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;把想到的全部写下來。然后把第一段跟最后一段拿掉。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每天都要好好大便。身体流畅了，思路才会流畅。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第一句话就要帶出感情。让读者感受到活生生的人，而不只是死板板的文章。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;大量写作。联系永远会让你进步一点点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;大量阅读。你一定要先读进去東西才写得出東西。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;动笔之前要先阅读。读最高品质的作品，让你的写作水平跟著提升。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;咖啡。不喝咖啡，就不会有創造力。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;別管物理法则。文字是沒有时间观念的。不需要凡事照順序写。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;标题要能震惊別人。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;说真话。把所有人都在想，但是沒人敢讲的東西写出來。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;別为了红而攻击別人。別当这种小人。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;睡满八小时。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当一个很有意见的人。若你对事情不是很有意见，那谁管你在想什么。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;把所有多余的句子部拿掉。有点多余就拿掉。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;跟风吧。找找現在有什么话題热门，就跟著谈阅吧。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;让观众掉眼泪。让他們想起那永不复返的曾经。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;谈一些社会上的真实故事。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;时间观念治愈一切。都过那么久了，把你那不堪回首的往事写出來吧。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不要打安全牌了。把想讲的全部写出來，写到你不敢公开文章为止。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;好笑一点。好笑第一法则：北烂的人都很好笑。让自己越北烂越好。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;多用句点。少用逗号、頓号、分号。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;让自己满脑都是想法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不要刻意去激怒某个人。让那个人也变成你的读者吧。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用你讲话的语气去写作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;你写的每一个句子都要內含价值。就算只是网上发动态也一样。除此之外，就保持安靜。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;搞懂大家在想什么，然后去探索、提出反面看法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每天都写東西。写作是一种精神修行。探索自己的內在，清掉一切的杂质。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;让文章的最后一句整个炸开來。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不要害怕別人怎么想。你每担心一个人，文章品质就降低1%。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用「说」就好，別用其他字。不要用「他建议…」、「他咆哮著…」。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;多画画。让其他和创意有关的部位都保持运动。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;睡一觉再说。不管你在写什么，暂停下來、睡一觉再说。之后再看过一次。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;原创：http://www.jamesaltucher.com/2011/03/33-unusual-tips-to-being-a-better-writer/
翻译：http://feed.wordcorp.net/blog/post/33-writing-tips&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>博客中添加社会化评论的方法</title>
   <link href="http://lanyon.getpoole.com/2015/12/20/comment/"/>
   <updated>2015-12-20T00:00:00+08:00</updated>
   <id>http://lanyon.getpoole.comhttp://gyk6985432.github.io/myBlog/2015/12/20/comment</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;“社会化评论”&lt;/strong&gt;也叫第三方评论，“社会化”听着很奇怪，难以理解，第三方评论就可以顾名思义，就是在自己的网站中加入评论的部分，但是这并不需要建立用户的注册系统以及相关的数据库，而是用QQ、微博等账号登录即可进行评论，给游客带来很多方便，而引入又极其方便，因此有简单省事的东西不拿来用简直对不起自己。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;常用的评论系统有&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;友言&lt;/li&gt;
  &lt;li&gt;畅言&lt;/li&gt;
  &lt;li&gt;多说&lt;/li&gt;
  &lt;li&gt;灯鹭&lt;/li&gt;
  &lt;li&gt;亦云&lt;/li&gt;
  &lt;li&gt;评论啦&lt;/li&gt;
  &lt;li&gt;贝米&lt;/li&gt;
  &lt;li&gt;Disqus&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在墙外活动的朋友可以试试Disqus，毕竟人家在全世界应用广泛，Google+，Facebook，Twitter账户都可以用，还是很方便的。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;用法&lt;/h2&gt;

&lt;p&gt;具体用法我就拿Disqus和友言来说吧，Disqus稍稍麻烦一点。&lt;/p&gt;

&lt;h3 id=&quot;disqus&quot;&gt;Disqus&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;进入&lt;a href=&quot;https://disqus.com/&quot;&gt;Disqus官方网站&lt;/a&gt;，没账户的先注册一个。&lt;/li&gt;
  &lt;li&gt;按指示的完成注册并登录后，随便关注三个community，也可以选选自己喜欢的。&lt;/li&gt;
  &lt;li&gt;点击右上角的setting-&amp;gt;Admin-&amp;gt;Edit Settings&lt;/li&gt;
  &lt;li&gt;左边栏里选择Installation，按照你的网站的类型选择，实在不知道就选Universal Code。&lt;/li&gt;
  &lt;li&gt;把那段代码复制，并粘贴到你的模板中即可。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;是的，这样就可以了。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;友言&lt;/h3&gt;

&lt;p&gt;这个就更简单啦，&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;直接到&lt;a href=&quot;http://www.uyan.cc/&quot;&gt;官网&lt;/a&gt;，注册。&lt;/li&gt;
  &lt;li&gt;获取代码-&amp;gt;选择网站类型&lt;/li&gt;
  &lt;li&gt;复制代码，粘贴到模板中，一般放在&amp;lt;/body&amp;gt;或&lt;strong&gt;“content”&lt;/strong&gt;之后.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;大功告成。&lt;/p&gt;

&lt;p&gt;至于各个评论哪个好，这个见仁见智，自己测试一下也不麻烦，简单大方最重要。&lt;/p&gt;

&lt;p&gt;有用的话帮忙点个赞之类的，欢迎探讨。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>中转站</title>
   <link href="http://lanyon.getpoole.com/2015/12/18/my-sites/"/>
   <updated>2015-12-18T00:00:00+08:00</updated>
   <id>http://lanyon.getpoole.comhttp://gyk6985432.github.io/myBlog/2015/12/18/my sites</id>
   <content type="html">&lt;p&gt;刚搭建好博客，自然得放点东西，不然总觉得空空的好难受。好吧，那就把我箱底的东西翻腾翻腾吧~`(&lt;em&gt;∩_∩&lt;/em&gt;)′~
首先上点导航，把这当成个中转站，否则长时间不上，万一给忘了这个地方可咋整，嗯？&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;常去的技术分享&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/&quot;&gt;github&lt;/a&gt;
&lt;a href=&quot;http://stackoverflow.com/&quot;&gt;stackoverflow&lt;/a&gt;
&lt;a href=&quot;http://toutiao.io/&quot;&gt;开发者头条&lt;/a&gt;
&lt;a href=&quot;http://geek.csdn.net/hotest&quot;&gt;极客头条&lt;/a&gt;
&lt;a href=&quot;http://gold.xitu.io/#/&quot;&gt;掘金&lt;/a&gt;
&lt;a href=&quot;http://www.cnblogs.com/&quot;&gt;博客园&lt;/a&gt;
&lt;a href=&quot;http://thestartupnews.com/&quot;&gt;StartUpNews&lt;/a&gt;
&lt;a href=&quot;http://www.importnew.com/&quot;&gt;ImportNew&lt;/a&gt;
&lt;a href=&quot;http://blog.jobbole.com/&quot;&gt;伯乐在线&lt;/a&gt;
&lt;a href=&quot;http://v2ex.com/&quot;&gt;v2ex&lt;/a&gt;
&lt;a href=&quot;http://codecloud.net/&quot;&gt;codecloud&lt;/a&gt;
&lt;a href=&quot;http://blog.codinghorror.com/&quot;&gt;codingHorror&lt;/a&gt;
&lt;a href=&quot;http://www.iteye.com/&quot;&gt;iteye&lt;/a&gt;
&lt;a href=&quot;https://www.reddit.com/&quot;&gt;reddit&lt;/a&gt;
&lt;a href=&quot;http://www.codeproject.com/&quot;&gt;CodeProject&lt;/a&gt;
&lt;a href=&quot;https://news.ycombinator.com/news&quot;&gt;HackerNews&lt;/a&gt;
&lt;a href=&quot;https://dzone.com/&quot;&gt;DZone&lt;/a&gt;
&lt;a href=&quot;https://lobste.rs/&quot;&gt;lobsters&lt;/a&gt;
&lt;a href=&quot;https://bytes.com/&quot;&gt;bytes&lt;/a&gt;
&lt;a href=&quot;http://news.oneapm.com/&quot;&gt;OneAPM&lt;/a&gt;
&lt;a href=&quot;https://rubygems.org/&quot;&gt;rubygems&lt;/a&gt;
&lt;a href=&quot;http://pineapple.io/?reset=true&quot;&gt;pineapple&lt;/a&gt;
&lt;a href=&quot;http://www.codeceo.com/&quot;&gt;码农网&lt;/a&gt;
&lt;a href=&quot;http://coolshell.cn/&quot;&gt;coolshell&lt;/a&gt;
&lt;a href=&quot;http://www.devtf.cn/&quot;&gt;开发技术前线&lt;/a&gt;
&lt;a href=&quot;http://www.jianshu.com/&quot;&gt;简书&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;经典导航&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://gate.guokr.com/&quot;&gt;果壳任意门&lt;/a&gt;
&lt;a href=&quot;http://1nami.com/&quot;&gt;1纳米学习&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;网盘&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.wangpansou.cn/&quot;&gt;网盘搜&lt;/a&gt;
&lt;a href=&quot;http://bwss.nlic.net.cn:8080/poweb/&quot;&gt;博云资料&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.tmtpost.com/&quot;&gt;钛媒体&lt;/a&gt;
&lt;a href=&quot;http://bluereader.org/&quot;&gt;深蓝阅读&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;编程资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/ms123401.aspx&quot;&gt;MSDN中文&lt;/a&gt;
&lt;a href=&quot;http://wiki.jikexueyuan.com/project/bootstrap4/&quot;&gt;bootstrap4&lt;/a&gt;
&lt;a href=&quot;https://developer.mozilla.org/zh-CN/&quot;&gt;Mozilla开发者网络&lt;/a&gt;
&lt;a href=&quot;http://jingxuan.io/markdown/&quot;&gt;markdown&lt;/a&gt;
&lt;a href=&quot;https://repo.spring.io/webapp/#/artifacts/browse/tree/General/libs-release-local/org/springframework/spring/4.2.3.RELEASE/spring-framework-4.2.3.RELEASE-docs.zip&quot;&gt;spring下载&lt;/a&gt;
&lt;a href=&quot;http://mvnrepository.com/&quot;&gt;maven库&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;程序员的后院&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://drops.wooyun.org/&quot;&gt;乌云知识库&lt;/a&gt;
&lt;a href=&quot;https://www.livecoding.tv/&quot;&gt;编程在线&lt;/a&gt;
&lt;a href=&quot;http://info.9iphp.com/&quot;&gt;程序员资源网&lt;/a&gt;
&lt;a href=&quot;http://www.aliyun.com/&quot;&gt;阿里云&lt;/a&gt;
&lt;a href=&quot;http://www.apcow.com/&quot;&gt;远程工作者&lt;/a&gt;
&lt;a href=&quot;http://www.vertex42.com/&quot;&gt;表格大全&lt;/a&gt;
&lt;a href=&quot;https://ttt.tt/&quot;&gt;通天塔&lt;/a&gt;
&lt;a href=&quot;http://bbs.pediy.com/index.php&quot;&gt;看雪安全&lt;/a&gt;
&lt;a href=&quot;http://www.freebuf.com/&quot;&gt;freebuf&lt;/a&gt;
&lt;a href=&quot;https://nmap.org/&quot;&gt;nmap&lt;/a&gt;
&lt;a href=&quot;http://jekyll.bootcss.com/docs/posts/&quot;&gt;jekyll文档&lt;/a&gt;
&lt;a href=&quot;https://shimo.im/&quot;&gt;石墨文档&lt;/a&gt;
&lt;a href=&quot;https://docs.google.com/&quot;&gt;谷歌文档&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;学院&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://mooc.guokr.com/&quot;&gt;mooc学院&lt;/a&gt;
&lt;a href=&quot;http://www.mooc.cn/&quot;&gt;慕课中国&lt;/a&gt;
&lt;a href=&quot;http://www.jikexueyuan.com/&quot;&gt;极客学院&lt;/a&gt;
&lt;a href=&quot;https://www.coursera.org/&quot;&gt;coursera&lt;/a&gt;
&lt;a href=&quot;https://www.hackerrank.com/&quot;&gt;hackerrank&lt;/a&gt;
&lt;a href=&quot;https://www.edx.org/&quot;&gt;edx&lt;/a&gt;
&lt;a href=&quot;https://www.udemy.com/&quot;&gt;udemy&lt;/a&gt;
&lt;a href=&quot;https://teamtreehouse.com/&quot;&gt;treehouse&lt;/a&gt;
&lt;a href=&quot;https://www.codecademy.com/&quot;&gt;codecademy&lt;/a&gt;
&lt;a href=&quot;https://code.org/&quot;&gt;code.org&lt;/a&gt;
&lt;a href=&quot;http://www.runoob.com/&quot;&gt;runoob&lt;/a&gt;
&lt;a href=&quot;http://visualgo.net/&quot;&gt;算法可视化&lt;/a&gt;
&lt;a href=&quot;https://www.shiyanlou.com/&quot;&gt;实验楼&lt;/a&gt;
&lt;a href=&quot;http://www.fanshuxueyuan.com/&quot;&gt;番薯学院&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;购物&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.buytong.com/&quot;&gt;百通物流&lt;/a&gt;
&lt;a href=&quot;https://www.taobao.com/&quot;&gt;淘宝&lt;/a&gt;
&lt;a href=&quot;http://www.jd.com/&quot;&gt;京东&lt;/a&gt;
&lt;a href=&quot;http://www.amazon.cn/&quot;&gt;亚马逊&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;文艺青年&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.asknature.org/&quot;&gt;问自然&lt;/a&gt;
&lt;a href=&quot;http://get.yousician.com/&quot;&gt;学吉他&lt;/a&gt;
&lt;a href=&quot;http://www.popiano.org/piano/index.htm&quot;&gt;钢琴谱&lt;/a&gt;
&lt;a href=&quot;http://www.mosh.cn/&quot;&gt;魔时同城&lt;/a&gt;
&lt;a href=&quot;http://www.rubik.com.cn/&quot;&gt;魔方小站&lt;/a&gt;
&lt;a href=&quot;http://www.ximalaya.com/&quot;&gt;喜马拉雅电台&lt;/a&gt;
&lt;a href=&quot;https://www.chesscademy.com/&quot;&gt;ChessCademy&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;设计&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.uisdc.com/&quot;&gt;优设&lt;/a&gt;
&lt;a href=&quot;http://www.splitshire.com/&quot;&gt;splitshire&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;个人网站&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/&quot;&gt;阮一峰&lt;/a&gt;
&lt;a href=&quot;http://www.barretlee.com/entry/&quot;&gt;小胡子哥&lt;/a&gt;
&lt;a href=&quot;http://coolshell.info/index.html&quot;&gt;浮生志&lt;/a&gt;
&lt;a href=&quot;http://blog.knownsec.com/&quot;&gt;知道创宇博客&lt;/a&gt;
&lt;a href=&quot;http://www.liaoxuefeng.com/&quot;&gt;廖雪峰的官方网站&lt;/a&gt;
&lt;a href=&quot;http://linuxtools-rst.readthedocs.org/&quot;&gt;Linux快速教程&lt;/a&gt;
&lt;a href=&quot;http://mindhacks.cn/&quot;&gt;刘未鹏&lt;/a&gt;
&lt;a href=&quot;http://greengerong.com/&quot;&gt;破狼&lt;/a&gt;
&lt;a href=&quot;http://prog-notes.yuanbin.me/index.html&quot;&gt;billryan&lt;/a&gt;
&lt;a href=&quot;http://ffffound.sinaapp.com/&quot;&gt;dog&lt;/a&gt;
&lt;a href=&quot;http://zh.lucida.me/&quot;&gt;lucida&lt;/a&gt;
&lt;a href=&quot;http://darkhouse.com.cn/blog/list&quot;&gt;darkhouse&lt;/a&gt;
&lt;a href=&quot;http://www.cnblogs.com/givebest/&quot;&gt;givebest&lt;/a&gt;
&lt;a href=&quot;http://bbear.me/&quot;&gt;bbear&lt;/a&gt;
&lt;a href=&quot;http://www.blogjava.net/&quot;&gt;blogjava&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;墙外&lt;/h2&gt;

&lt;h2 id=&quot;section-12&quot;&gt;学术&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://ieeexplore.ieee.org/&quot;&gt;IEEE&lt;/a&gt;
&lt;a href=&quot;http://wiki.opencv.org.cn&quot;&gt;OpenCV&lt;/a&gt;
&lt;a href=&quot;http://bbs.elecfans.com/&quot;&gt;电子发烧友&lt;/a&gt;
&lt;a href=&quot;http://xyclade.github.io/MachineLearning/&quot;&gt;MachineLearning&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;先放一部分吧，慢慢再找。欢迎补充~~&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Welcome to my blog</title>
   <link href="http://lanyon.getpoole.com/2015/12/18/A-New-Tutorial/"/>
   <updated>2015-12-18T00:00:00+08:00</updated>
   <id>http://lanyon.getpoole.comhttp://gyk6985432.github.io/myBlog/2015/12/18/A-New-Tutorial</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;/images/SplitShire_9573.jpg&quot; alt=&quot;Alt text&quot; /&gt;
Through one day and a half, I finish this blog finally. This is tough…
I hope I can share my experience about coding and learning process.&lt;/p&gt;

&lt;p&gt;Please look forward~~&lt;/p&gt;

</content>
 </entry>
 

</feed>
