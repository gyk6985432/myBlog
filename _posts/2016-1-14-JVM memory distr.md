---
layout: post
title: JVM内存区域及作用
---

最近在看《深入理解JAVA虚拟机》，刚看到内存区域划分及其所管理的内容。虽然在其他博客上也看过类似的文章，但书里介绍的还是更加详尽透彻。这些区域不太好记，容易遗忘，写篇博客常常回来温习一下也好。

### 运行时数据区域

![Alt text](/myBlog/images/Java VM structure.png)

#### 程序计数器（Program Counter Register）
程序计数器是一块较小的内存空间，可看作当前线程执行的字节码的行号指示器。用来给*字节码解释器*进行选取字节码指令，以及分支、循环、跳转、异常处理、线程恢复等功能。
为了线程切换后能恢复到正确的执行位置，需要给每条线程都创建一个程序计数器，因而也叫“线程私有”的内存。如果线程执行的java方法，该计数器指向的是正在执行的字节码地址，若是Native方法，则指向空（Undefined）。
此内存区域是java虚拟机唯一一个没有规定任何OutOfMemoryError的区域。

#### Java虚拟机栈（Java Virtual Machine Stacks）
这块区域也是线程私有的，其生命周期与线程相同。
虚拟机栈是给**执行java方法**服务的。每个java方法执行时都会创建一个**栈帧(Stack Frame)**，用于存储局部变量表、操作数栈、动态链接、方法出口等。java方法的调用的过程对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；若虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。

#### 本地方法栈（Native Method Stack）
本地方法栈和虚拟机栈的区别在于它是为Native方法服务的。虚拟机规范对本地方法栈中使用的语言、使用方式和数据结构没有强制规定，不同虚拟机可自由实现。而虚拟机栈中用到的boolean、byte、char、int、double、对象引用的内存分配都在编译时候分配完成，进入一个方法时栈帧的局部变量空间是完全确定的，运行期间不会改变。

#### Java堆（Java Heap）
java堆是内存中最大的部分，所有线程所共享的，虚拟机启动时创建，用来存放对象实例和数组。内存回收也是主要针对这部分，为了便于回收，java堆会被分成Eden、From Survivor、To Survivor等，这部分内容以后进行介绍。
如果堆中没有内存分配给实例，并且堆也无法扩展时将会抛出OutOfMemoryError异常。

#### 方法区（Method Area）
方法区也是所有线程共享的区域，用来存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。方法区也是java堆的逻辑部分，但为了与java堆有所区别，也叫*非堆(Non-Heap)*。虽然有些称方法区为“永久代”，但这却不是绝对的，垃圾回收器主要对这部分中的常量池的进行回收和类型的卸载，防止某些时候出现的内存泄漏。。
虚拟机规范规定，方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

#### 运行时常量池（Runtime Constant Pool）
运行时常量池是方法区的一部分，Class文件中除了类的信息、字段、方法、接口等外，还有一项*常量池（Constant Pool Table）*用于存放编译期生成的各种字面量和符号引用，这部分内容要放到运行时常量池中存放。
但是运行时常量池不仅可以存放编译期生成的常量部分，也可在运行时将新的常量放入池中，，具有动态存储的特性。如String的intern()方法。
运行时长两次无法申请到内存时会抛出OutOfMemoryError异常。

#### 直接内存
这部分不是运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但由于会经常使用，也应该予以关注。
JDK1.4中新加入的NIO类，引入了基于通道（channel）与缓冲区（Buffer）的I/O方式，可以使用Native函数库直接分配堆外内存，通过DirectByteBuffer对象作为这块内存的引用进行操作。这种方法能显著提高性能，避免了java堆和Native堆中来回复制数据。
在配置虚拟机参数时，要兼顾这部分直接内存，保证总内存大于各内存区域总和，防止导致出现OutOfMemoryError异常。





