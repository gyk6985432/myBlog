---
layout: post
title: JVM中的四种引用
---

看过某些博客中看到，在面试中有时会问到“弱引用”的问题，很多面试者都答不上来，让我也一直很迷惑。在书中看到才真正理解了不同“引用”的作用，终于知道了finalize()方法的作用。

## 可达性分析算法
主流语言包括Java、C#等都是通过可达性分析来判定对象是否应该继续存活。其基本思想是设置一系列的起始点（GC Roots）对象，沿着引用链（Reference Chain）向下搜索，当一个对象没有任何路径能够到达GC Roots时，说明对象是不可达的。

## 四种引用
JDK1.2中对引用的概念进行了扩充，分为：
- 强引用（Strong Reference）
- 软引用（Soft Reference）
- 弱引用（Weak Reference）
- 虚引用（Phantom Reference）

强引用是指在程序代码中普遍存在的“Object obj = new Object()”一类引用，垃圾回收器永远不会对有强引用的对象进行回收。

软引用描述的是有用但并非必需的对象，。系统在将要发生内存溢出异常之前，会把软引用的对象进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。

弱引用也是描述非必需对象的，但它比软引用更弱，被弱引用关联的对象只能生存道下一次垃圾收集发生之前。无论当前内存是否足够，都会回收被弱引用关联的对象。

虚引用又称为幽灵引用或幻影引用，是最弱的一种引用关系。一个对象是否有虚引用，完全不影响其生存时间，也无法通过虚引用来生成一个对象实例。虚引用唯一的作用是，在对象被回收时会受到一个系统通知。


## finalize()方法
当一个对象变得不可达时，系统并不会立即给它判死刑，且马上进行回收。在它死之前还会给它一次机会，也就是第一次给予严重警告，如果它不能自我救赎，第二次就了结它。那如何标记是第一次还是第二次呢？这就要借助finalize()方法了。
如果一个对象没有实现finalize()方法，或者已经调用过finalize()方法，就认定它没有机会了，直接进行回收。如果它有finalize()方法并且没有执行过，就给它一次机会，这时此对象将被放置到一个叫做F-QUEUE的队列中，并在稍后由Finalizer线程去执行。Finalizer线程是由虚拟机自动建立、具有低优先级的一个线程。
此时，虽然该对象的finalize()被执行了，但虚拟机并不会等待它结束，防止它执行缓慢或陷入死循环，让F-QUEUE中其他对象永久处于等待状态，导致整个内存回收系统崩溃。
finalize()方法是对象逃过鬼门关的最后一次机会，稍后GC将对F-QUEUE中的对象进行第二次小规模标记，对象要成功地拯救自己，只有重新与引用链上的任何一个对象建立关联，这时它将不再是“即将”被回收的对象了。









