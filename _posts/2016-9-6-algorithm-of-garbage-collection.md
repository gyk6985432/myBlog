---
layout: post
title: 垃圾收集器及垃圾收集算法
---

垃圾收集技术经历过很长时间的发展，已经不需要像C++语言里让每个程序员都要分出一部分精力来处理内存的分配和回收这种繁杂的事情了。在我的理解中，程序或计算机的发展趋势就是用机器来代替人做一些重复的劳动，让人从中解放出来，垃圾回收器也正是这样一种机制。

# 一 垃圾回收算法

垃圾回收算法有：标记-清除算法、复制算法、标记-整理算法和分代收集算法。

## 1 标记-清除算法
该算法分为两个阶段，首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。
>一个对象在回收前通常要经历两次标记的过程，如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，则它将会被第一次标记并进行第一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有重写finalize()方法或finalize()已经被虚拟机调用过，则判定为“没有必要执行”。finalize()是对象逃脱死亡命运的最后一次机会。

接着GC会对F-Queue中的对象执行第二次标记，如果对象通过finalize()方法与引用链相连接，则不会被回收，否则对象将被回收。

标记-清除算法存在两个不足：标记和清除两个过程的效率都不高，而且标记清除后产生大量的内存碎片。

其他所有算法都是针对这两个问题进行了改进而产生的。

## 2 复制算法
复制算法是为解决“效率”问题出现的，它将内存分为两块，每次使用其中一块，当使用的一块用完时，将存活的对象复制到另外一块，然后将原来的空间清理掉，同时解决了内存碎片化的问题。
通常商业虚拟机将内存分为一块Eden和两块Survivor，大小比例为8:1:1，每次使用Eden和其中一块Survivor，将存活对象复制到另一块Survivor上面。
这样做避免了内存空间的浪费，当存活对象较多时，会依赖老年代来进行分配担保。

## 3 标记-整理算法
复制算法要进行多次复制操作，效率可能会变低，另外分配担保也存在风险，老年代不适合采用这种方法。
标记-整理算法的标记过程与上述过程一样，但并不是直接清理对象，而是让存活的对象向一端移动，清理掉边界以外的内存。

## 4 分代收集算法
分代收集就是根据对象存活的时间不同，将Java堆分为新生代和老年代，针对不同的对象采用不同的回收算法。

# 二 垃圾回收器

新生代收集器有：Serial、ParNew、ParallelScavenge。
老年代收集器有：CMS、SerialOld、ParallelOld。
最新收集器：G1。

## 1 Serial收集器
Serial是单线程收集器，采用复制算法，在进行垃圾收集时，必须停止其他工作线程，即Stop The World(STW)。它是虚拟机在Client模式下的默认新生代收集器。
在桌面应用程序中，虚拟机内存一般为几十兆到几百兆，停顿时间大概为几十毫秒到一百多毫秒的范围内，对一般应用程序来说是可以接受的。

## 2 ParNew收集器
ParNew是Serial收集器的多线程版，也存在Stop The World的问题，除了是多线程的实现外，并没有很多的创新之处。因此ParNew通常运行在Server模式下的新生代收集器。
另外它只能与CMS收集器配合使用。

## 3 Parallel Scavenge收集器
Parallel Scavenge收集器是新生代收集器，采用的是复制算法，其目标是达到一个可控制的吞吐量(Throughput)，即运行用户代码时间/(运行用户代码时间+垃圾收集时间)，因此也被称为“吞吐量优先收集器”。

## 4 Serial Old收集器
Serial Old收集器是Serial收集器的老年代版本，也是单线程运行的使用了“标记-整理算法”，以供在Client模式下运行，但在Server模式下可以与Parallel Scavenge收集器配合使用，也可以作为CMS的备选方案。

## 5 Parallel Old收集器
Parallel Old是Parallel Scavenge收集器的老年代版本，使用“标记-整理算法”，在注重吞吐量的场合可以使用Parallel Old和Parallel Scavenge的组合。

## 6 CMS收集器
CMS全称为Concurrent Mark Sweep收集器，可以看出采用的是“标记-清除算法”，其目标是获得最短停顿时间，通常应用在网站或B/S服务器上，以期获得最短停顿时间和最快的响应速度。从总体上说，CMS收集器是与用户线程一起并发执行的，虽然其中也有Stop The World，但相对时间很短。因此也称为“并发低停顿收集器”。
CMS不足之处在于在服务器上工作时会占用一部分线程，使吞吐量降低。另外CMS无法处理浮动垃圾(同时运行的用户线程时产生的新垃圾)。最后使用标记清除算法会产生大量的空间碎片，出现虽然还有内存但无法分配大对象的情况。

## 7 G1收集器
有关G1收集器的原理可参照文章http://www.importnew.com/15311.html

reference：
1. 深入理解Java虚拟机
2. (JVM垃圾回收机制)[http://jbutton.iteye.com/blog/1569746]